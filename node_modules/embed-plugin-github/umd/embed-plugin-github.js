(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.embedPluginGithub = factory());
}(this, (function () { 'use strict';

var justExtend = extend;
function extend() {
    var args = [].slice.call(arguments);
    var deep = false;
    if (typeof args[0] == 'boolean') {
        deep = args.shift();
    }
    var result = args[0];
    if (!result || typeof result != 'object' && typeof result != 'function') {
        throw new Error('extendee must be an object');
    }
    var extenders = args.slice(1);
    var len = extenders.length;
    for (var i = 0;i < len; i++) {
        var extender = extenders[i];
        for (var key in extender) {
            if (extender.hasOwnProperty(key)) {
                var value = extender[key];
                if (deep && isCloneable(value)) {
                    var base = Array.isArray(value) ? [] : {};
                    result[key] = extend(true, result.hasOwnProperty(key) ? result[key] : base, value);
                } else {
                    result[key] = value;
                }
            }
        }
    }
    return result;
}

function isCloneable(obj) {
    return Array.isArray(obj) || ({}).toString.call(obj) == '[object Object]';
}

function matchAll(str, re) {
    var matches = [];
    var res = re.exec(str);
    while (res) {
        matches.push(res);
        if (!re.global) {
            break;
        }
        res = re.exec(str);
    }
    return matches;
}

function replaceAll(str, matches) {
    return matches.reverse().reduce(function (res, match) {
        var prefix = res.slice(0, match.index);
        var postfix = res.slice(match.index + match[0].length);
        return prefix + match.replacement + postfix;
    }, str);
}

function assignReplacement(match, replacer) {
    var args = match.concat([match.index,match.input]);
    return replacer.apply(null, args).then(function (res) {
        return justExtend({}, match, {
            replacement: res
        });
    });
}

function concurrency(matches, replacer) {
    var promises = matches.map(function (match) {
        return assignReplacement(match, replacer);
    });
    return Promise.all(promises);
}

function processString(str, re, replacer) {
    var matches = matchAll(str, re);
    var processor = concurrency;
    return processor(matches, replacer).then(function (matches) {
        return replaceAll(str, matches);
    });
}

function stringReplaceAsync(str, re, replacer) {
    re.lastIndex = 0;
    try {
        return Promise.resolve(processString(str, re, replacer));
    } catch (e) {
        return Promise.reject(e);
    }
}

var anchorRegex = /<a[^>]*>([^<]+)<\/a>/gi;
function getAnchorRegex(regex) {
    return new RegExp(("<a[^>]*>(" + (regex.source) + ")<\\/a>"), "gi");
}

function isMatchPresent(regex, text, test) {
    if ( test === void 0 ) test = false;

    return test ? regex.test(text) : text.match(regex);
}

function isAnchorTagApplied(ref, ref$1) {
    var result = ref.result;
    var plugins = ref.plugins; if ( plugins === void 0 ) plugins = [];
    var regex = ref$1.regex;

    return getAnchorRegex(regex).test(result) || plugins.filter(function (plugin) { return plugin.id === "url"; }).length;
}

function saveServiceName(ref, ref$1, match) {
    var _services = ref._services;
    var id = ref$1.id;

    if (!_services.filter(function (x) { return x.match === match; }).length) {
        _services.push({
            id: id,
            match: match
        });
    }
}

function pushEmbedContent(text, options, pluginOptions, index) {
    return new Promise(function ($return, $error) {
        var regex;
        var assign;
        ((assign = pluginOptions, regex = assign.regex));
        return stringReplaceAsync(text, regex, function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            return new Promise(function ($return, $error) { return getTemplate(args, options, pluginOptions).then(function ($await_7) {
            try {
                options._embeds.push({
                    content: $await_7,
                    index: index || args.find(function (x) { return typeof x === "number"; })
                });
                saveServiceName(options, pluginOptions, args[0]);
                return $return();
            } catch ($boundEx) {
                return $error($boundEx);
            }
        }, $error); });
        }).then(function ($await_8) {
            try {
                return $return(options);
            } catch ($boundEx) {
                return $error($boundEx);
            }
        }, $error);
    });
}

function saveEmbedData(opts, pluginOptions) {
    var this$1 = this;

    return new Promise(function ($return, $error) {
        var regex;
        var options;
        var assign;
        ((assign = pluginOptions, regex = assign.regex));
        options = justExtend({}, opts);
        if (isAnchorTagApplied(options, {
            regex: regex
        })) {
            return stringReplaceAsync(options.result, anchorRegex, function (match, url, index) { return new Promise(function ($return, $error) {
                if (!isMatchPresent(regex, match, true)) 
                    { return $return(match); }
                saveServiceName(options, pluginOptions, match);
                return pushEmbedContent(url, options, pluginOptions, index).then(function ($await_9) {
                    try {
                        options = $await_9;
                        return $return(match);
                    } catch ($boundEx) {
                        return $error($boundEx);
                    }
                }, $error);
            }); }).then(function ($await_10) {
                try {
                    return $If_3.call(this$1);
                } catch ($boundEx) {
                    return $error($boundEx);
                }
            }, $error);
        } else {
            options = pushEmbedContent(options.result, options, pluginOptions);
            return $If_3.call(this$1);
        }
        function $If_3() {
            return $return(options);
        }
        
    });
}

function getMatch(regex, string) {
    regex.lastIndex = 0;
    var matches = regex.exec(string);
    regex.lastIndex = 0;
    return matches;
}

function getTemplate(args, options, pluginOptions) {
    var this$1 = this;

    return new Promise(function ($return, $error) {
        var _process, template;
        var data;
        var assign;
        ((assign = pluginOptions, _process = assign._process, template = assign.template));
        if (_process) {
            return _process(args, options, pluginOptions).then(function ($await_11) {
                try {
                    data = $await_11;
                    return $If_4.call(this$1);
                } catch ($boundEx) {
                    return $error($boundEx);
                }
            }, $error);
        }
        function $If_4() {
            return $return(template(args, options, pluginOptions, data));
        }
        
        return $If_4.call(this$1);
    });
}

function basicReplace(options, pluginOptions) {
    return new Promise(function ($return, $error) {
        var result = options.result;
        var replaceUrl = options.replaceUrl;
        var regex = pluginOptions.regex;
        var _replaceAnyways = pluginOptions._replaceAnyways;
        return $return(stringReplaceAsync(result, regex, function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            return new Promise(function ($return, $error) {
            saveServiceName(options, pluginOptions, args[0]);
            return new Promise(function ($return, $error) {
                if (replaceUrl || _replaceAnyways) 
                    { return $return(getTemplate(args, options, pluginOptions)); }
                return getTemplate(args, options, pluginOptions).then(function ($await_12) {
                    try {
                        return $return(((args[0]) + " " + $await_12));
                    } catch ($boundEx) {
                        return $error($boundEx);
                    }
                }, $error);
            }).then($return, $error);
        });
        }));
    });
}

function anchorReplace(options, pluginOptions) {
    return new Promise(function ($return, $error) {
        var result = options.result;
        var replaceUrl = options.replaceUrl;
        var regex = pluginOptions.regex;
        var _replaceAnyways = pluginOptions._replaceAnyways;
        return $return(stringReplaceAsync(result, anchorRegex, function (match, url) { return new Promise(function ($return, $error) {
            var args, t;
            if (!isMatchPresent(regex, url, true)) {
                return $return(match);
            }
            if (!(replaceUrl || _replaceAnyways)) {
                args = getMatch(regex, url);
                saveServiceName(options, pluginOptions, args[0]);
                return getTemplate(args, options, pluginOptions).then(function ($await_14) {
                    try {
                        t = $await_14;
                        return $return(args ? match + t : match);
                    } catch ($boundEx) {
                        return $error($boundEx);
                    }
                }, $error);
            }
            return $return(stringReplaceAsync(url, regex, function () {
                var args = [], len = arguments.length;
                while ( len-- ) args[ len ] = arguments[ len ];

                return new Promise(function ($return, $error) {
                saveServiceName(options, pluginOptions, args[0]);
                return $return(getTemplate(args, options, pluginOptions));
            });
            }));
        }); }));
    });
}

var insert = function (options, pluginOptions) {
    return new Promise(function ($return, $error) {
        var inlineEmbed, _ignoreAnchorCheck, _ignoreInlineCheck, regex;
        var output;
        var assign;
        ((assign = options, inlineEmbed = assign.inlineEmbed));
        var assign$1;
        ((assign$1 = pluginOptions, _ignoreAnchorCheck = assign$1._ignoreAnchorCheck, _ignoreInlineCheck = assign$1._ignoreInlineCheck, regex = assign$1.regex));
        if (!inlineEmbed && !_ignoreInlineCheck) {
            return $return(saveEmbedData(options, pluginOptions));
        }
        return new Promise(function ($return, $error) {
            if (isAnchorTagApplied(options, {
                regex: regex
            }) && !_ignoreAnchorCheck) {
                return anchorReplace(options, pluginOptions).then($return, $error);
            }
            return basicReplace(options, pluginOptions).then($return, $error);
        }).then(function ($await_17) {
            try {
                output = $await_17;
                return $return(justExtend({}, options, {
                    result: output
                }));
            } catch ($boundEx) {
                return $error($boundEx);
            }
        }, $error);
    });
};

var justTruncate = truncate;
function truncate(str, length, end) {
    if (length == null || length >= str.length) {
        return str;
    }
    if (end == null) {
        end = '...';
    }
    return str.slice(0, Math.max(0, length - end.length)) + end;
}

var withDetailsTemplate = function (ref, thumbClassName, showPlayIcon) {
    var url = ref.url;
    var title = ref.title;
    var embedUrl = ref.embedUrl;
    var description = ref.description;
    var thumbnail = ref.thumbnail;
    if ( showPlayIcon === void 0 ) showPlayIcon = false;

    return ("<div class=\"ejs-preview ejs-embed\"><div class=\"ejs-thumb " + thumbClassName + "\" data-url=\"" + embedUrl + "\" style=\"background-image:url(" + thumbnail + ")\">" + (showPlayIcon ? '<span>&#9658;</span>' : '') + "</div><div class=\"ejs-info\"><h4 class=\"ejs-title\"><a href=\"" + url + "\">" + title + "</a></h4><div class=\"ejs-desc\">" + (justTruncate(description, 150)) + "</div></div></div>");
};

var base = function (opts) {
    var defaultOptions = {
        _replaceAnyways: false,
        _ignoreAnchorCheck: false,
        _ignoreInlineCheck: false,
        onLoad: function onLoad() {}
    };
    var pluginOptions = justExtend({}, defaultOptions, opts);
    var _onLoadInternal = pluginOptions._onLoadInternal;
    var onLoad = pluginOptions.onLoad;
    var regex = pluginOptions.regex;
    var template = pluginOptions.template;
    var id = pluginOptions.id;
    if (!regex) {
        throw new Error("regex not passed.");
    }
    if (!template) {
        throw new Error("template not passed.");
    }
    return {
        id: id,
        transform: function transform(options) {
            return new Promise(function ($return, $error) { return insert(options, pluginOptions).then(function ($await_1) {
                try {
                    return $return(justExtend({}, options, $await_1));
                } catch ($boundEx) {
                    return $error($boundEx);
                }
            }, $error); });
        },
        onLoad: function onLoad$1(options) {
            if (_onLoadInternal) {
                _onLoadInternal(options, pluginOptions);
            }
            if (onLoad) {
                onLoad(options, pluginOptions);
            }
        }
    };
};

var id = "github";
function _process(args, ref) {
    var fetch = ref.fetch;

    return new Promise(function ($return, $error) {
        var user, repo, res;
        var assign;
        (assign = args, user = assign[1], repo = assign[2]);
        var $Try_1_Post = function () {
            try {
                return $return();
            } catch ($boundEx) {
                return $error($boundEx);
            }
        };
        var $Try_1_Catch = function (e) {
            try {
                return $return({});
            } catch ($boundEx) {
                return $error($boundEx);
            }
        };
        try {
            return fetch(("https://api.github.com/repos/" + user + "/" + repo)).then(function ($await_2) {
                try {
                    res = $await_2;
                    return $return(res.json());
                } catch ($boundEx) {
                    return $Try_1_Catch($boundEx);
                }
            }, $Try_1_Catch);
        } catch (e) {
            $Try_1_Catch(e);
        }
    });
}

function github(opts) {
    var defaultOptions = {
        id: id,
        regex: /[^\.]github.com\/([\w\.\-]+)\/([\w\.\-]+[^\.])/gi,
        template: function template(args, options, pluginOptions, ref) {
            var owner = ref.owner;
            var description = ref.description;
            var html_url = ref.html_url;
            var full_name = ref.full_name;

            return new Promise(function ($return, $error) { return $return(withDetailsTemplate({
                thumbnail: owner.avatar_url,
                url: html_url,
                description: description,
                title: full_name
            })); });
        }
    };
    var pluginOptions = justExtend({}, defaultOptions, opts, {
        _process: _process
    });
    return base(pluginOptions);
}

github.id = id;

return github;

})));
//# sourceMappingURL=embed-plugin-github.js.map
