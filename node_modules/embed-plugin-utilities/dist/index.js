'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var extend = _interopDefault(require('just-extend'));
var truncate = _interopDefault(require('just-truncate'));

function matchAll(str, re) {
    const matches = [];
    let res = re.exec(str);
    while (res) {
        matches.push(res);
        if (!re.global) {
            break;
        }
        res = re.exec(str);
    }
    return matches;
}

function replaceAll(str, matches) {
    return matches.reverse().reduce(function (res, match) {
        const prefix = res.slice(0, match.index);
        const postfix = res.slice(match.index + match[0].length);
        return prefix + match.replacement + postfix;
    }, str);
}

function assignReplacement(match, replacer) {
    const args = match.concat([match.index,match.input]);
    return replacer.apply(null, args).then(function (res) {
        return extend({}, match, {
            replacement: res
        });
    });
}

function concurrency(matches, replacer) {
    const promises = matches.map(function (match) {
        return assignReplacement(match, replacer);
    });
    return Promise.all(promises);
}

function processString(str, re, replacer) {
    const matches = matchAll(str, re);
    const processor = concurrency;
    return processor(matches, replacer).then(function (matches) {
        return replaceAll(str, matches);
    });
}

function stringReplaceAsync(str, re, replacer) {
    re.lastIndex = 0;
    try {
        return Promise.resolve(processString(str, re, replacer));
    } catch (e) {
        return Promise.reject(e);
    }
}

const anchorRegex = /<a[^>]*>([^<]+)<\/a>/gi;
function getAnchorRegex(regex) {
    return new RegExp(`<a[^>]*>(${regex.source})<\\/a>`, "gi");
}

function isMatchPresent(regex, text, test = false) {
    return test ? regex.test(text) : text.match(regex);
}

function isAnchorTagApplied({result, plugins = []}, {regex}) {
    return getAnchorRegex(regex).test(result) || plugins.filter(plugin => plugin.id === "url").length;
}

function saveServiceName({_services}, {id}, match) {
    if (!_services.filter(x => x.match === match).length) {
        _services.push({
            id,
            match
        });
    }
}

function pushEmbedContent(text, options, pluginOptions, index) {
    return new Promise(($return, $error) => {
        var regex;
        ({regex} = pluginOptions);
        return stringReplaceAsync(text, regex, (...args) => new Promise(($return, $error) => getTemplate(args, options, pluginOptions).then($await_7 => {
            try {
                options._embeds.push({
                    content: $await_7,
                    index: index || args.find(x => typeof x === "number")
                });
                saveServiceName(options, pluginOptions, args[0]);
                return $return();
            } catch ($boundEx) {
                return $error($boundEx);
            }
        }, $error))).then($await_8 => {
            try {
                return $return(options);
            } catch ($boundEx) {
                return $error($boundEx);
            }
        }, $error);
    });
}

function saveEmbedData(opts, pluginOptions) {
    return new Promise(($return, $error) => {
        var regex;
        let options;
        ({regex} = pluginOptions);
        options = extend({}, opts);
        if (isAnchorTagApplied(options, {
            regex
        })) {
            return stringReplaceAsync(options.result, anchorRegex, (match, url, index) => new Promise(($return, $error) => {
                if (!isMatchPresent(regex, match, true)) 
                    return $return(match);
                saveServiceName(options, pluginOptions, match);
                return pushEmbedContent(url, options, pluginOptions, index).then($await_9 => {
                    try {
                        options = $await_9;
                        return $return(match);
                    } catch ($boundEx) {
                        return $error($boundEx);
                    }
                }, $error);
            })).then($await_10 => {
                try {
                    return $If_3.call(this);
                } catch ($boundEx) {
                    return $error($boundEx);
                }
            }, $error);
        } else {
            options = pushEmbedContent(options.result, options, pluginOptions);
            return $If_3.call(this);
        }
        function $If_3() {
            return $return(options);
        }
        
    });
}

function getMatch(regex, string) {
    regex.lastIndex = 0;
    const matches = regex.exec(string);
    regex.lastIndex = 0;
    return matches;
}

function getTemplate(args, options, pluginOptions) {
    return new Promise(($return, $error) => {
        var _process, template;
        let data;
        ({_process, template} = pluginOptions);
        if (_process) {
            return _process(args, options, pluginOptions).then($await_11 => {
                try {
                    data = $await_11;
                    return $If_4.call(this);
                } catch ($boundEx) {
                    return $error($boundEx);
                }
            }, $error);
        }
        function $If_4() {
            return $return(template(args, options, pluginOptions, data));
        }
        
        return $If_4.call(this);
    });
}

function basicReplace(options, pluginOptions) {
    return new Promise(($return, $error) => {
        const {result, replaceUrl} = options;
        const {regex, _replaceAnyways} = pluginOptions;
        return $return(stringReplaceAsync(result, regex, (...args) => new Promise(($return, $error) => {
            saveServiceName(options, pluginOptions, args[0]);
            return new Promise(($return, $error) => {
                if (replaceUrl || _replaceAnyways) 
                    return $return(getTemplate(args, options, pluginOptions));
                return getTemplate(args, options, pluginOptions).then($await_12 => {
                    try {
                        return $return(`${args[0]} ${$await_12}`);
                    } catch ($boundEx) {
                        return $error($boundEx);
                    }
                }, $error);
            }).then($return, $error);
        })));
    });
}

function anchorReplace(options, pluginOptions) {
    return new Promise(($return, $error) => {
        const {result, replaceUrl} = options;
        const {regex, _replaceAnyways} = pluginOptions;
        return $return(stringReplaceAsync(result, anchorRegex, (match, url) => new Promise(($return, $error) => {
            var args, t;
            if (!isMatchPresent(regex, url, true)) {
                return $return(match);
            }
            if (!(replaceUrl || _replaceAnyways)) {
                args = getMatch(regex, url);
                saveServiceName(options, pluginOptions, args[0]);
                return getTemplate(args, options, pluginOptions).then($await_14 => {
                    try {
                        t = $await_14;
                        return $return(args ? match + t : match);
                    } catch ($boundEx) {
                        return $error($boundEx);
                    }
                }, $error);
            }
            return $return(stringReplaceAsync(url, regex, (...args) => new Promise(($return, $error) => {
                saveServiceName(options, pluginOptions, args[0]);
                return $return(getTemplate(args, options, pluginOptions));
            })));
        })));
    });
}

var insert = function (options, pluginOptions) {
    return new Promise(($return, $error) => {
        var inlineEmbed, _ignoreAnchorCheck, _ignoreInlineCheck, regex;
        let output;
        ({inlineEmbed} = options);
        ({_ignoreAnchorCheck, _ignoreInlineCheck, regex} = pluginOptions);
        if (!inlineEmbed && !_ignoreInlineCheck) {
            return $return(saveEmbedData(options, pluginOptions));
        }
        return new Promise(($return, $error) => {
            if (isAnchorTagApplied(options, {
                regex
            }) && !_ignoreAnchorCheck) {
                return anchorReplace(options, pluginOptions).then($return, $error);
            }
            return basicReplace(options, pluginOptions).then($return, $error);
        }).then($await_17 => {
            try {
                output = $await_17;
                return $return(extend({}, options, {
                    result: output
                }));
            } catch ($boundEx) {
                return $error($boundEx);
            }
        }, $error);
    });
};

var withDetailsTemplate = function ({url, title, embedUrl, description, thumbnail}, thumbClassName, showPlayIcon = false) {
    return `<div class="ejs-preview ejs-embed"><div class="ejs-thumb ${thumbClassName}" data-url="${embedUrl}" style="background-image:url(${thumbnail})">${showPlayIcon ? '<span>&#9658;</span>' : ''}</div><div class="ejs-info"><h4 class="ejs-title"><a href="${url}">${title}</a></h4><div class="ejs-desc">${truncate(description, 150)}</div></div></div>`;
};

var withoutDetailsTemplate = function (embedUrl, height, name) {
    return `<iframe class="ejs-embed ejs-${name}" src="${embedUrl}" frameBorder="0" height="${height}"></iframe>`;
};

var getQuery = function (params) {
    const esc = encodeURIComponent;
    return Object.keys(params).map(k => `${esc(k)}=${esc(params[k])}`).join("&");
};

exports.insert = insert;
exports.withDetailsTemplate = withDetailsTemplate;
exports.withoutDetailsTemplate = withoutDetailsTemplate;
exports.getQuery = getQuery;
