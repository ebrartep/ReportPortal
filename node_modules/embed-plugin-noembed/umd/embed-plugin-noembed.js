(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.embedPluginNoembed = factory());
}(this, (function () { 'use strict';

var justExtend = extend;
function extend() {
    var args = [].slice.call(arguments);
    var deep = false;
    if (typeof args[0] == 'boolean') {
        deep = args.shift();
    }
    var result = args[0];
    if (!result || typeof result != 'object' && typeof result != 'function') {
        throw new Error('extendee must be an object');
    }
    var extenders = args.slice(1);
    var len = extenders.length;
    for (var i = 0;i < len; i++) {
        var extender = extenders[i];
        for (var key in extender) {
            if (extender.hasOwnProperty(key)) {
                var value = extender[key];
                if (deep && isCloneable(value)) {
                    var base = Array.isArray(value) ? [] : {};
                    result[key] = extend(true, result.hasOwnProperty(key) ? result[key] : base, value);
                } else {
                    result[key] = value;
                }
            }
        }
    }
    return result;
}

function isCloneable(obj) {
    return Array.isArray(obj) || ({}).toString.call(obj) == '[object Object]';
}

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
} : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};
var isBrowser = (typeof window === "undefined" ? "undefined" : _typeof(window)) === "object" && (typeof document === "undefined" ? "undefined" : _typeof(document)) === 'object' && document.nodeType === 9;

var isDom = isNode;
function isNode(val) {
    return !val || typeof val !== 'object' ? false : typeof window === 'object' && typeof window.Node === 'object' ? val instanceof window.Node : typeof val.nodeType === 'number' && typeof val.nodeName === 'string';
}

var justPluckIt = pluck;
function pluck(collection, propertyName) {
    if (!collection || typeof collection != 'object') {
        return new Error('expected first argument to be an object or array');
    }
    var result, len, i, keys, key;
    if (Array.isArray(collection)) {
        result = [];
        len = collection.length;
        for (i = 0; i < len; i++) {
            result.push(collection[i][propertyName]);
        }
    } else {
        result = {};
        keys = Object.keys(collection);
        len = keys.length;
        for (i = 0; i < len; i++) {
            key = keys[i];
            result[key] = collection[key][propertyName];
        }
    }
    return result;
}

var justFlattenIt = flatten;
function flatten(arr) {
    if (!Array.isArray(arr)) {
        throw new Error('expected an array');
    }
    var result = [];
    var len = arr.length;
    for (var i = 0;i < len; i++) {
        var elem = arr[i];
        if (Array.isArray(elem)) {
            result.push.apply(result, flatten(elem));
        } else {
            result.push(elem);
        }
    }
    return result;
}

var regexes = [{
    patterns: ["https?://soundcloud.com/.*/.[^\\s]*"],
    name: "SoundCloud"
},{
    name: "slideshare",
    patterns: ["https?://www\\.slideshare\\.net/.*/.[^\\s]*","https?://fr\\.slideshare\\.net/.*/.[^\\s]*",
        "https?://de\\.slideshare\\.net/.*/.[^\\s]*","https?://es\\.slideshare\\.net/.*/.[^\\s]*",
        "https?://pt\\.slideshare\\.net/.*/.[^\\s]*"]
},{
    name: "vimeo",
    patterns: ["https?://vimeo\\.com/.[^\\s]*","https?://vimeo\\.com/album/.*/video/.[^\\s]*",
        "https?://vimeo\\.com/channels/.*/.[^\\s]*","https?://vimeo\\.com/groups/.*/videos/.[^\\s]*",
        "https?://vimeo\\.com/ondemand/.*/.[^\\s]*"]
},{
    patterns: ["https?://photos\\.app\\.net/.*/.[^\\s]*","https?://live\\.amcharts\\.com/.[^\\s]*",
        "https?://codepen\\.io/.[^\\s]*","https?://codepen\\.io/.[^\\s]*","https?://www\\.collegehumor\\.com/video/.[^\\s]*",
        "https?://www\\.dailymotion\\.com/video/.[^\\s]*","https?://.*\\.deviantart\\.com/art/.[^\\s]*",
        "https?://.*\\.deviantart\\.com/.*#/d.[^\\s]*","https?://dotsub\\.com/view/.[^\\s]*",
        "https?://.*\\.flickr\\.com/photos/.[^\\s]*","https?://flic\\.kr/p/.[^\\s]*",
        "https?://.*\\.wikimedia\\.org/.*_geograph\\.org\\.uk_.[^\\s]*","https?://gfycat\\.com/.[^\\s]*",
        "https?://www\\.gfycat\\.com/.[^\\s]*","https?://gfycat\\.com/.[^\\s]*","https?://www\\.gfycat\\.com/.[^\\s]*",
        "https?://giphy\\.com/gifs/.[^\\s]*","https?://media\\.giphy\\.com/media/.*/giphy\\.gif",
        "https?://www\\.hulu\\.com/watch/.[^\\s]*","https?://www\\.kickstarter\\.com/projects/.[^\\s]*",
        "https?://www\\.mixcloud\\.com/.*/.*/","https?://reddit\\.com/r/.*/comments/.*/.[^\\s]*",
        "https?://.*\\.screen9\\.tv/.[^\\s]*","https?://www\\.scribd\\.com/doc/.[^\\s]*",
        "https?://.*\\.smugmug\\.com/.[^\\s]*","https?://soundcloud\\.com/.[^\\s]*",
        "https?://play\\.soundsgood\\.co/playlist/.[^\\s]*","https?://speakerdeck\\.com/.*/.[^\\s]*",
        "https?://speakerdeck\\.com/.*/.[^\\s]*","https?://ted\\.com/talks/.[^\\s]*",
        "https?://www\\.nytimes\\.com/svc/oembed","https?://nytimes\\.com/.[^\\s]*",
        "https?://.*\\.nytimes\\.com/.[^\\s]*","https?://clips\\.twitch\\.tv/.[^\\s]*",
        "https?://clips\\.twitch\\.tv/.[^\\s]*","https?://www\\.twitch\\.tv/.[^\\s]*",
        "https?://www\\.twitch\\.tv/.[^\\s]*","https?://twitch\\.tv/.[^\\s]*","https?://twitch\\.tv/.[^\\s]*",
        "https?://.*\\.ustream\\.tv/.[^\\s]*","https?://.*\\.ustream\\.com/.[^\\s]*",
        "https?://veervr\\.tv/videos/.[^\\s]*","https?://www\\.vevo\\.com/.[^\\s]*",
        "https?://www\\.vevo\\.com/.[^\\s]*","https?://player\\.vimeo\\.com/video/.[^\\s]*",
        "https?://vine\\.co/v/.[^\\s]*","https?://vine\\.co/v/.[^\\s]*"],
    name: "oEmbed"
},{
    name: "Imgur",
    patterns: ["https?://imgur\\.com/(?:[^\\/]+/)?[0-9a-zA-Z]+$"]
},{
    patterns: ["https?://www\\.(dropbox\\.com/s/.+\\.(?:jpg|png|gif))","https?://db\\.tt/[a-zA-Z0-9][^\\s]+"],
    name: "Dropbox"
},{
    patterns: ["https?:\\/\\/(?:[^\\.]+\\.)?youtube\\.com\\/watch\\/?\\?(?:.+&)?v=([^&][^\\s]+)",
        "https?://(?:[^\\.]+\\.)?(?:youtu\\.be|youtube\\.com/embed)/([a-zA-Z0-9_-][^\\s]+)"],
    name: "YouTube"
},{
    patterns: ["https?://(?:www|mobile\\.)?twitter\\.com/(?:#!/)?([^/]+)/status(?:es)?/(\\d+)"],
    name: "Twitter"
}];
function getRegexes(excludeServices) {
    if ( excludeServices === void 0 ) excludeServices = [];

    var includedRegexes = regexes.filter(function (r) { return excludeServices.indexOf(r.name.toLowerCase()) === -1; });
    var patterns = justFlattenIt(justPluckIt(includedRegexes, "patterns"));
    return new RegExp(patterns.join("|"), "gi");
}

function isServicePresent(serviceName, text) {
    var service = regexes.filter(function (r) { return r.name.toLowerCase() === serviceName; })[0];
    var regex = new RegExp(service.patterns.join("|"), "gi");
    return regex.test(text);
}

function matchAll(str, re) {
    var matches = [];
    var res = re.exec(str);
    while (res) {
        matches.push(res);
        if (!re.global) {
            break;
        }
        res = re.exec(str);
    }
    return matches;
}

function replaceAll(str, matches) {
    return matches.reverse().reduce(function (res, match) {
        var prefix = res.slice(0, match.index);
        var postfix = res.slice(match.index + match[0].length);
        return prefix + match.replacement + postfix;
    }, str);
}

function assignReplacement(match, replacer) {
    var args = match.concat([match.index,match.input]);
    return replacer.apply(null, args).then(function (res) {
        return justExtend({}, match, {
            replacement: res
        });
    });
}

function concurrency(matches, replacer) {
    var promises = matches.map(function (match) {
        return assignReplacement(match, replacer);
    });
    return Promise.all(promises);
}

function processString(str, re, replacer) {
    var matches = matchAll(str, re);
    var processor = concurrency;
    return processor(matches, replacer).then(function (matches) {
        return replaceAll(str, matches);
    });
}

function stringReplaceAsync(str, re, replacer) {
    re.lastIndex = 0;
    try {
        return Promise.resolve(processString(str, re, replacer));
    } catch (e) {
        return Promise.reject(e);
    }
}

var anchorRegex = /<a[^>]*>([^<]+)<\/a>/gi;
function getAnchorRegex(regex) {
    return new RegExp(("<a[^>]*>(" + (regex.source) + ")<\\/a>"), "gi");
}

function isMatchPresent(regex, text, test) {
    if ( test === void 0 ) test = false;

    return test ? regex.test(text) : text.match(regex);
}

function isAnchorTagApplied(ref, ref$1) {
    var result = ref.result;
    var plugins = ref.plugins; if ( plugins === void 0 ) plugins = [];
    var regex = ref$1.regex;

    return getAnchorRegex(regex).test(result) || plugins.filter(function (plugin) { return plugin.id === "url"; }).length;
}

function saveServiceName(ref, ref$1, match) {
    var _services = ref._services;
    var id = ref$1.id;

    if (!_services.filter(function (x) { return x.match === match; }).length) {
        _services.push({
            id: id,
            match: match
        });
    }
}

function pushEmbedContent(text, options, pluginOptions, index) {
    return new Promise(function ($return, $error) {
        var regex;
        var assign;
        ((assign = pluginOptions, regex = assign.regex));
        return stringReplaceAsync(text, regex, function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            return new Promise(function ($return, $error) { return getTemplate(args, options, pluginOptions).then(function ($await_7) {
            try {
                options._embeds.push({
                    content: $await_7,
                    index: index || args.find(function (x) { return typeof x === "number"; })
                });
                saveServiceName(options, pluginOptions, args[0]);
                return $return();
            } catch ($boundEx) {
                return $error($boundEx);
            }
        }, $error); });
        }).then(function ($await_8) {
            try {
                return $return(options);
            } catch ($boundEx) {
                return $error($boundEx);
            }
        }, $error);
    });
}

function saveEmbedData(opts, pluginOptions) {
    var this$1 = this;

    return new Promise(function ($return, $error) {
        var regex;
        var options;
        var assign;
        ((assign = pluginOptions, regex = assign.regex));
        options = justExtend({}, opts);
        if (isAnchorTagApplied(options, {
            regex: regex
        })) {
            return stringReplaceAsync(options.result, anchorRegex, function (match, url, index) { return new Promise(function ($return, $error) {
                if (!isMatchPresent(regex, match, true)) 
                    { return $return(match); }
                saveServiceName(options, pluginOptions, match);
                return pushEmbedContent(url, options, pluginOptions, index).then(function ($await_9) {
                    try {
                        options = $await_9;
                        return $return(match);
                    } catch ($boundEx) {
                        return $error($boundEx);
                    }
                }, $error);
            }); }).then(function ($await_10) {
                try {
                    return $If_3.call(this$1);
                } catch ($boundEx) {
                    return $error($boundEx);
                }
            }, $error);
        } else {
            options = pushEmbedContent(options.result, options, pluginOptions);
            return $If_3.call(this$1);
        }
        function $If_3() {
            return $return(options);
        }
        
    });
}

function getMatch(regex, string) {
    regex.lastIndex = 0;
    var matches = regex.exec(string);
    regex.lastIndex = 0;
    return matches;
}

function getTemplate(args, options, pluginOptions) {
    var this$1 = this;

    return new Promise(function ($return, $error) {
        var _process, template;
        var data;
        var assign;
        ((assign = pluginOptions, _process = assign._process, template = assign.template));
        if (_process) {
            return _process(args, options, pluginOptions).then(function ($await_11) {
                try {
                    data = $await_11;
                    return $If_4.call(this$1);
                } catch ($boundEx) {
                    return $error($boundEx);
                }
            }, $error);
        }
        function $If_4() {
            return $return(template(args, options, pluginOptions, data));
        }
        
        return $If_4.call(this$1);
    });
}

function basicReplace(options, pluginOptions) {
    return new Promise(function ($return, $error) {
        var result = options.result;
        var replaceUrl = options.replaceUrl;
        var regex = pluginOptions.regex;
        var _replaceAnyways = pluginOptions._replaceAnyways;
        return $return(stringReplaceAsync(result, regex, function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            return new Promise(function ($return, $error) {
            saveServiceName(options, pluginOptions, args[0]);
            return new Promise(function ($return, $error) {
                if (replaceUrl || _replaceAnyways) 
                    { return $return(getTemplate(args, options, pluginOptions)); }
                return getTemplate(args, options, pluginOptions).then(function ($await_12) {
                    try {
                        return $return(((args[0]) + " " + $await_12));
                    } catch ($boundEx) {
                        return $error($boundEx);
                    }
                }, $error);
            }).then($return, $error);
        });
        }));
    });
}

function anchorReplace(options, pluginOptions) {
    return new Promise(function ($return, $error) {
        var result = options.result;
        var replaceUrl = options.replaceUrl;
        var regex = pluginOptions.regex;
        var _replaceAnyways = pluginOptions._replaceAnyways;
        return $return(stringReplaceAsync(result, anchorRegex, function (match, url) { return new Promise(function ($return, $error) {
            var args, t;
            if (!isMatchPresent(regex, url, true)) {
                return $return(match);
            }
            if (!(replaceUrl || _replaceAnyways)) {
                args = getMatch(regex, url);
                saveServiceName(options, pluginOptions, args[0]);
                return getTemplate(args, options, pluginOptions).then(function ($await_14) {
                    try {
                        t = $await_14;
                        return $return(args ? match + t : match);
                    } catch ($boundEx) {
                        return $error($boundEx);
                    }
                }, $error);
            }
            return $return(stringReplaceAsync(url, regex, function () {
                var args = [], len = arguments.length;
                while ( len-- ) args[ len ] = arguments[ len ];

                return new Promise(function ($return, $error) {
                saveServiceName(options, pluginOptions, args[0]);
                return $return(getTemplate(args, options, pluginOptions));
            });
            }));
        }); }));
    });
}

var insert = function (options, pluginOptions) {
    return new Promise(function ($return, $error) {
        var inlineEmbed, _ignoreAnchorCheck, _ignoreInlineCheck, regex;
        var output;
        var assign;
        ((assign = options, inlineEmbed = assign.inlineEmbed));
        var assign$1;
        ((assign$1 = pluginOptions, _ignoreAnchorCheck = assign$1._ignoreAnchorCheck, _ignoreInlineCheck = assign$1._ignoreInlineCheck, regex = assign$1.regex));
        if (!inlineEmbed && !_ignoreInlineCheck) {
            return $return(saveEmbedData(options, pluginOptions));
        }
        return new Promise(function ($return, $error) {
            if (isAnchorTagApplied(options, {
                regex: regex
            }) && !_ignoreAnchorCheck) {
                return anchorReplace(options, pluginOptions).then($return, $error);
            }
            return basicReplace(options, pluginOptions).then($return, $error);
        }).then(function ($await_17) {
            try {
                output = $await_17;
                return $return(justExtend({}, options, {
                    result: output
                }));
            } catch ($boundEx) {
                return $error($boundEx);
            }
        }, $error);
    });
};

var base = function (opts) {
    var defaultOptions = {
        _replaceAnyways: false,
        _ignoreAnchorCheck: false,
        _ignoreInlineCheck: false,
        onLoad: function onLoad() {}
    };
    var pluginOptions = justExtend({}, defaultOptions, opts);
    var _onLoadInternal = pluginOptions._onLoadInternal;
    var onLoad = pluginOptions.onLoad;
    var regex = pluginOptions.regex;
    var template = pluginOptions.template;
    var id = pluginOptions.id;
    if (!regex) {
        throw new Error("regex not passed.");
    }
    if (!template) {
        throw new Error("template not passed.");
    }
    return {
        id: id,
        transform: function transform(options) {
            return new Promise(function ($return, $error) { return insert(options, pluginOptions).then(function ($await_1) {
                try {
                    return $return(justExtend({}, options, $await_1));
                } catch ($boundEx) {
                    return $error($boundEx);
                }
            }, $error); });
        },
        onLoad: function onLoad$1(options) {
            if (_onLoadInternal) {
                _onLoadInternal(options, pluginOptions);
            }
            if (onLoad) {
                onLoad(options, pluginOptions);
            }
        }
    };
};

var id = "noEmbed";
function _process(args, ref) {
    var fetch = ref.fetch;

    return new Promise(function ($return, $error) {
        var url, res;
        url = args[0];
        var $Try_1_Post = function () {
            try {
                return $return();
            } catch ($boundEx) {
                return $error($boundEx);
            }
        };
        var $Try_1_Catch = function (e) {
            try {
                return $return({
                    html: url
                });
            } catch ($boundEx) {
                return $error($boundEx);
            }
        };
        try {
            return fetch(("https://noembed.com/embed?url=" + url)).then(function ($await_2) {
                try {
                    res = $await_2;
                    return res.json().then($return, $Try_1_Catch);
                } catch ($boundEx) {
                    return $Try_1_Catch($boundEx);
                }
            }, $Try_1_Catch);
        } catch (e) {
            $Try_1_Catch(e);
        }
    });
}

function noEmbed(opts) {
    if ( opts === void 0 ) opts = {};

    var defaultOptions = {
        id: id,
        regex: null,
        exclude: [],
        twttr: isBrowser ? window.twttr : null,
        onLoad: function onLoad() {},
        template: function template(args, options, pluginOptions, ref) {
            var html = ref.html;

            return new Promise(function ($return, $error) { return $return(("<div class=\"ejs-embed\">" + html + "</div>")); });
        },
        _onLoadInternal: function _onLoadInternal(ref, ref$1) {
            var input = ref.input;
            var result = ref.result;
            var twttr = ref$1.twttr;
            var onLoad = ref$1.onLoad;

            if (isServicePresent("twitter", result) && twttr && isDom(input)) {
                twttr.widgets.load(input);
                twttr.events.bind("loaded", onLoad);
            }
        }
    };
    var pluginOptions = justExtend({}, defaultOptions, opts, {
        _process: _process
    });
    if (!opts.regex) {
        pluginOptions.regex = getRegexes(pluginOptions.exclude);
    }
    return base(pluginOptions);
}

noEmbed.id = id;

return noEmbed;

})));
//# sourceMappingURL=embed-plugin-noembed.js.map
