(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.embedPluginTwitter = factory());
}(this, (function () { 'use strict';

var justExtend = extend;
function extend() {
    var args = [].slice.call(arguments);
    var deep = false;
    if (typeof args[0] == 'boolean') {
        deep = args.shift();
    }
    var result = args[0];
    if (!result || typeof result != 'object' && typeof result != 'function') {
        throw new Error('extendee must be an object');
    }
    var extenders = args.slice(1);
    var len = extenders.length;
    for (var i = 0;i < len; i++) {
        var extender = extenders[i];
        for (var key in extender) {
            if (extender.hasOwnProperty(key)) {
                var value = extender[key];
                if (deep && isCloneable(value)) {
                    var base = Array.isArray(value) ? [] : {};
                    result[key] = extend(true, result.hasOwnProperty(key) ? result[key] : base, value);
                } else {
                    result[key] = value;
                }
            }
        }
    }
    return result;
}

function isCloneable(obj) {
    return Array.isArray(obj) || ({}).toString.call(obj) == '[object Object]';
}

var isDom = isNode;
function isNode(val) {
    return !val || typeof val !== 'object' ? false : typeof window === 'object' && typeof window.Node === 'object' ? val instanceof window.Node : typeof val.nodeType === 'number' && typeof val.nodeName === 'string';
}

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
} : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};
var isBrowser = (typeof window === "undefined" ? "undefined" : _typeof(window)) === "object" && (typeof document === "undefined" ? "undefined" : _typeof(document)) === 'object' && document.nodeType === 9;

function matchAll(str, re) {
    var matches = [];
    var res = re.exec(str);
    while (res) {
        matches.push(res);
        if (!re.global) {
            break;
        }
        res = re.exec(str);
    }
    return matches;
}

function replaceAll(str, matches) {
    return matches.reverse().reduce(function (res, match) {
        var prefix = res.slice(0, match.index);
        var postfix = res.slice(match.index + match[0].length);
        return prefix + match.replacement + postfix;
    }, str);
}

function assignReplacement(match, replacer) {
    var args = match.concat([match.index,match.input]);
    return replacer.apply(null, args).then(function (res) {
        return justExtend({}, match, {
            replacement: res
        });
    });
}

function concurrency(matches, replacer) {
    var promises = matches.map(function (match) {
        return assignReplacement(match, replacer);
    });
    return Promise.all(promises);
}

function processString(str, re, replacer) {
    var matches = matchAll(str, re);
    var processor = concurrency;
    return processor(matches, replacer).then(function (matches) {
        return replaceAll(str, matches);
    });
}

function stringReplaceAsync(str, re, replacer) {
    re.lastIndex = 0;
    try {
        return Promise.resolve(processString(str, re, replacer));
    } catch (e) {
        return Promise.reject(e);
    }
}

var anchorRegex = /<a[^>]*>([^<]+)<\/a>/gi;
function getAnchorRegex(regex) {
    return new RegExp(("<a[^>]*>(" + (regex.source) + ")<\\/a>"), "gi");
}

function isMatchPresent(regex, text, test) {
    if ( test === void 0 ) test = false;

    return test ? regex.test(text) : text.match(regex);
}

function isAnchorTagApplied(ref, ref$1) {
    var result = ref.result;
    var plugins = ref.plugins; if ( plugins === void 0 ) plugins = [];
    var regex = ref$1.regex;

    return getAnchorRegex(regex).test(result) || plugins.filter(function (plugin) { return plugin.id === "url"; }).length;
}

function saveServiceName(ref, ref$1, match) {
    var _services = ref._services;
    var id = ref$1.id;

    if (!_services.filter(function (x) { return x.match === match; }).length) {
        _services.push({
            id: id,
            match: match
        });
    }
}

function pushEmbedContent(text, options, pluginOptions, index) {
    return new Promise(function ($return, $error) {
        var regex;
        var assign;
        ((assign = pluginOptions, regex = assign.regex));
        return stringReplaceAsync(text, regex, function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            return new Promise(function ($return, $error) { return getTemplate(args, options, pluginOptions).then(function ($await_7) {
            try {
                options._embeds.push({
                    content: $await_7,
                    index: index || args.find(function (x) { return typeof x === "number"; })
                });
                saveServiceName(options, pluginOptions, args[0]);
                return $return();
            } catch ($boundEx) {
                return $error($boundEx);
            }
        }, $error); });
        }).then(function ($await_8) {
            try {
                return $return(options);
            } catch ($boundEx) {
                return $error($boundEx);
            }
        }, $error);
    });
}

function saveEmbedData(opts, pluginOptions) {
    var this$1 = this;

    return new Promise(function ($return, $error) {
        var regex;
        var options;
        var assign;
        ((assign = pluginOptions, regex = assign.regex));
        options = justExtend({}, opts);
        if (isAnchorTagApplied(options, {
            regex: regex
        })) {
            return stringReplaceAsync(options.result, anchorRegex, function (match, url, index) { return new Promise(function ($return, $error) {
                if (!isMatchPresent(regex, match, true)) 
                    { return $return(match); }
                saveServiceName(options, pluginOptions, match);
                return pushEmbedContent(url, options, pluginOptions, index).then(function ($await_9) {
                    try {
                        options = $await_9;
                        return $return(match);
                    } catch ($boundEx) {
                        return $error($boundEx);
                    }
                }, $error);
            }); }).then(function ($await_10) {
                try {
                    return $If_3.call(this$1);
                } catch ($boundEx) {
                    return $error($boundEx);
                }
            }, $error);
        } else {
            options = pushEmbedContent(options.result, options, pluginOptions);
            return $If_3.call(this$1);
        }
        function $If_3() {
            return $return(options);
        }
        
    });
}

function getMatch(regex, string) {
    regex.lastIndex = 0;
    var matches = regex.exec(string);
    regex.lastIndex = 0;
    return matches;
}

function getTemplate(args, options, pluginOptions) {
    var this$1 = this;

    return new Promise(function ($return, $error) {
        var _process, template;
        var data;
        var assign;
        ((assign = pluginOptions, _process = assign._process, template = assign.template));
        if (_process) {
            return _process(args, options, pluginOptions).then(function ($await_11) {
                try {
                    data = $await_11;
                    return $If_4.call(this$1);
                } catch ($boundEx) {
                    return $error($boundEx);
                }
            }, $error);
        }
        function $If_4() {
            return $return(template(args, options, pluginOptions, data));
        }
        
        return $If_4.call(this$1);
    });
}

function basicReplace(options, pluginOptions) {
    return new Promise(function ($return, $error) {
        var result = options.result;
        var replaceUrl = options.replaceUrl;
        var regex = pluginOptions.regex;
        var _replaceAnyways = pluginOptions._replaceAnyways;
        return $return(stringReplaceAsync(result, regex, function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            return new Promise(function ($return, $error) {
            saveServiceName(options, pluginOptions, args[0]);
            return new Promise(function ($return, $error) {
                if (replaceUrl || _replaceAnyways) 
                    { return $return(getTemplate(args, options, pluginOptions)); }
                return getTemplate(args, options, pluginOptions).then(function ($await_12) {
                    try {
                        return $return(((args[0]) + " " + $await_12));
                    } catch ($boundEx) {
                        return $error($boundEx);
                    }
                }, $error);
            }).then($return, $error);
        });
        }));
    });
}

function anchorReplace(options, pluginOptions) {
    return new Promise(function ($return, $error) {
        var result = options.result;
        var replaceUrl = options.replaceUrl;
        var regex = pluginOptions.regex;
        var _replaceAnyways = pluginOptions._replaceAnyways;
        return $return(stringReplaceAsync(result, anchorRegex, function (match, url) { return new Promise(function ($return, $error) {
            var args, t;
            if (!isMatchPresent(regex, url, true)) {
                return $return(match);
            }
            if (!(replaceUrl || _replaceAnyways)) {
                args = getMatch(regex, url);
                saveServiceName(options, pluginOptions, args[0]);
                return getTemplate(args, options, pluginOptions).then(function ($await_14) {
                    try {
                        t = $await_14;
                        return $return(args ? match + t : match);
                    } catch ($boundEx) {
                        return $error($boundEx);
                    }
                }, $error);
            }
            return $return(stringReplaceAsync(url, regex, function () {
                var args = [], len = arguments.length;
                while ( len-- ) args[ len ] = arguments[ len ];

                return new Promise(function ($return, $error) {
                saveServiceName(options, pluginOptions, args[0]);
                return $return(getTemplate(args, options, pluginOptions));
            });
            }));
        }); }));
    });
}

var insert = function (options, pluginOptions) {
    return new Promise(function ($return, $error) {
        var inlineEmbed, _ignoreAnchorCheck, _ignoreInlineCheck, regex;
        var output;
        var assign;
        ((assign = options, inlineEmbed = assign.inlineEmbed));
        var assign$1;
        ((assign$1 = pluginOptions, _ignoreAnchorCheck = assign$1._ignoreAnchorCheck, _ignoreInlineCheck = assign$1._ignoreInlineCheck, regex = assign$1.regex));
        if (!inlineEmbed && !_ignoreInlineCheck) {
            return $return(saveEmbedData(options, pluginOptions));
        }
        return new Promise(function ($return, $error) {
            if (isAnchorTagApplied(options, {
                regex: regex
            }) && !_ignoreAnchorCheck) {
                return anchorReplace(options, pluginOptions).then($return, $error);
            }
            return basicReplace(options, pluginOptions).then($return, $error);
        }).then(function ($await_17) {
            try {
                output = $await_17;
                return $return(justExtend({}, options, {
                    result: output
                }));
            } catch ($boundEx) {
                return $error($boundEx);
            }
        }, $error);
    });
};

var getQuery = function (params) {
    var esc = encodeURIComponent;
    return Object.keys(params).map(function (k) { return ((esc(k)) + "=" + (esc(params[k]))); }).join("&");
};

var base = function (opts) {
    var defaultOptions = {
        _replaceAnyways: false,
        _ignoreAnchorCheck: false,
        _ignoreInlineCheck: false,
        onLoad: function onLoad() {}
    };
    var pluginOptions = justExtend({}, defaultOptions, opts);
    var _onLoadInternal = pluginOptions._onLoadInternal;
    var onLoad = pluginOptions.onLoad;
    var regex = pluginOptions.regex;
    var template = pluginOptions.template;
    var id = pluginOptions.id;
    if (!regex) {
        throw new Error("regex not passed.");
    }
    if (!template) {
        throw new Error("template not passed.");
    }
    return {
        id: id,
        transform: function transform(options) {
            return new Promise(function ($return, $error) { return insert(options, pluginOptions).then(function ($await_1) {
                try {
                    return $return(justExtend({}, options, $await_1));
                } catch ($boundEx) {
                    return $error($boundEx);
                }
            }, $error); });
        },
        onLoad: function onLoad$1(options) {
            if (_onLoadInternal) {
                _onLoadInternal(options, pluginOptions);
            }
            if (onLoad) {
                onLoad(options, pluginOptions);
            }
        }
    };
};

var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};





function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var fetchJsonp = createCommonjsModule(function (module, exports) {
    (function (global, factory) {
        if (typeof undefined === 'function' && undefined.amd) {
            undefined(['exports','module'], factory);
        } else {
            factory(exports, module);
        }
    })(commonjsGlobal, function (exports, module) {
        'use strict';
        var defaultOptions = {
            timeout: 5000,
            jsonpCallback: 'callback',
            jsonpCallbackFunction: null
        };
        function generateCallbackFunction() {
            return 'jsonp_' + Date.now() + '_' + Math.ceil(Math.random() * 100000);
        }
        
        function clearFunction(functionName) {
            try {
                delete window[functionName];
            } catch (e) {
                window[functionName] = undefined;
            }
        }
        
        function removeScript(scriptId) {
            var script = document.getElementById(scriptId);
            if (script) {
                document.getElementsByTagName('head')[0].removeChild(script);
            }
        }
        
        function fetchJsonp(_url) {
            var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
            var url = _url;
            var timeout = options.timeout || defaultOptions.timeout;
            var jsonpCallback = options.jsonpCallback || defaultOptions.jsonpCallback;
            var timeoutId = undefined;
            return new Promise(function (resolve, reject) {
                var callbackFunction = options.jsonpCallbackFunction || generateCallbackFunction();
                var scriptId = jsonpCallback + '_' + callbackFunction;
                window[callbackFunction] = function (response) {
                    resolve({
                        ok: true,
                        json: function json() {
                            return Promise.resolve(response);
                        }
                    });
                    if (timeoutId) 
                        { clearTimeout(timeoutId); }
                    removeScript(scriptId);
                    clearFunction(callbackFunction);
                };
                url += url.indexOf('?') === -1 ? '?' : '&';
                var jsonpScript = document.createElement('script');
                jsonpScript.setAttribute('src', '' + url + jsonpCallback + '=' + callbackFunction);
                if (options.charset) {
                    jsonpScript.setAttribute('charset', options.charset);
                }
                jsonpScript.id = scriptId;
                document.getElementsByTagName('head')[0].appendChild(jsonpScript);
                timeoutId = setTimeout(function () {
                    reject(new Error('JSONP request to ' + _url + ' timed out'));
                    clearFunction(callbackFunction);
                    removeScript(scriptId);
                    window[callbackFunction] = function () {
                        clearFunction(callbackFunction);
                    };
                }, timeout);
                jsonpScript.onerror = function () {
                    reject(new Error('JSONP request to ' + _url + ' failed'));
                    clearFunction(callbackFunction);
                    removeScript(scriptId);
                    if (timeoutId) 
                        { clearTimeout(timeoutId); }
                };
            });
        }
        
        module.exports = fetchJsonp;
    });
});

var id = "twitter";
function _process(args, ref, ref$1) {
    var fetch = ref.fetch;
    var _omitScript = ref$1._omitScript;
    var maxWidth = ref$1.maxWidth;
    var hideMedia = ref$1.hideMedia;
    var hideThread = ref$1.hideThread;
    var align = ref$1.align;
    var lang = ref$1.lang;
    var theme = ref$1.theme;
    var linkColor = ref$1.linkColor;
    var widgetType = ref$1.widgetType;

    return new Promise(function ($return, $error) {
        var params, apiUrl, res;
        params = {
            url: args[0],
            omitScript: _omitScript,
            maxWidth: maxWidth,
            hideMedia: hideMedia,
            hideThread: hideThread,
            align: align,
            lang: lang,
            theme: theme,
            linkColor: linkColor,
            widgetType: widgetType
        };
        var $Try_1_Post = function () {
            try {
                return $return();
            } catch ($boundEx) {
                return $error($boundEx);
            }
        };
        var $Try_1_Catch = function (e) {
            try {
                return $return({
                    html: ""
                });
            } catch ($boundEx) {
                return $error($boundEx);
            }
        };
        try {
            apiUrl = "https://api.twitter.com/1/statuses/oembed.json?" + (getQuery(params));
            return (isBrowser ? fetchJsonp : fetch)(apiUrl).then(function ($await_2) {
                try {
                    res = $await_2;
                    return res.json().then($return, $Try_1_Catch);
                } catch ($boundEx) {
                    return $Try_1_Catch($boundEx);
                }
            }, $Try_1_Catch);
        } catch (e) {
            $Try_1_Catch(e);
        }
    });
}

function renderTweet(ref, ref$1) {
    var input = ref.input;
    var _services = ref._services;
    var twttr = ref$1.twttr;
    var onLoad = ref$1.onLoad;

    if (!isDom(input)) {
        throw new Error("input should be a DOM element to embed tweet.");
    }
    if (_services.filter(function (service) { return service.id === "twitter"; }).length) {
        twttr.widgets.load(input);
        twttr.events.bind("loaded", onLoad);
    }
}

function twitter(opts) {
    var defaultOptions = {
        id: id,
        regex: /https:\/\/twitter\.com\/\w+\/\w+\/\d+/gi,
        maxWidth: 550,
        hideMedia: false,
        hideThread: false,
        align: "none",
        lang: "en",
        theme: "light",
        linkColor: "#355acee",
        widgetType: "",
        template: function template(args, options, pluginOptions, ref) {
            var html = ref.html;

            return html;
        },
        _omitScript: true,
        twttr: isBrowser ? window.twttr : null,
        _onLoadInternal: function _onLoadInternal(options, pluginOptions) {
            renderTweet(options, pluginOptions);
        },
        onLoad: function onLoad() {}
    };
    var pluginOptions = justExtend({}, defaultOptions, opts, {
        _process: _process
    });
    return base(pluginOptions);
}

twitter.id = id;

return twitter;

})));
//# sourceMappingURL=embed-plugin-twitter.js.map
